# iostat信息分析

`iostat`是我们在分析机器io问题时最常用到的工具，其基本用法如下:

```shell
-> % iostat -dxk 5
Device:    rrqm/s wrqm/s   r/s   w/s  rsec/s  wsec/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
sda          0.05  62.60  0.86  9.96   64.33    8.58    32.17     4.29     6.73     0.03   10.43   1.60   1.73
```

其中5为采样间隔，其余三个选项意义不详述，可参见`man iostat`，这里主要
解释一下`iostat`的各项输出的意义及可能反映出我们的机器在哪方面可能存在
问题。

### rrqm/s wrqm/s

read/write requests merged per second，即每秒钟merge的读/写请求次数。
这里解释一下merge的意思，操作系统在收到一个读写请求的时候，会根据要访
问文件的位置，在请求队列（request queue，以下简称rq）中查找访问相邻位
置的请求，如果有的话，就与其合并为一个请求，以减少io次数，提高效率。

### r/s w/s

read/write requests per second，即每秒钟读/写请求次数。

### rsec/s wsec/s及rkB/s wkB/s

read/write sectors/kBs per seconds，即每秒读/写的数据量的大小，单位为
扇区或者kB。该数值可以反映出磁盘的整体吞吐。

### avgqu-sz

average queue size，即平均请求队列长度。如果这个值比较小，那么你的系统
要么压力很小，要么大多数请求都是串行的（比如读请求）；反之，如果这个值
比较大，则说明你的上层应用能够充分的利用底层的磁盘，但是这种情况下其实
是在牺牲请求处理时间还换取更大的带宽。

### avgrq-sz

average request size，即平均请求大小，单位为sector。显然，少量的大请求
处理起来要比大量的小请求效率高得多，通过这个数值能够看出我们程序的io访问
模式是否合理。

### svctm

service time，平磁盘请求处理时间，这个数值只与底层磁盘的处理能力相关。
由于写操作能够比读操作更好的利用磁盘的cache，所以写请求的svctm通常要比
读请求的svctm小一些，大致在1ms左右。如果发现线上在大部分是写请求的情况
下svctm却比较高，那么很有可能是磁盘出了问题。

### await

average wait time，即平均等待时间，包括请求在队列中等待的时间和磁盘处
理该请求用的时间，体现了一个请求的整体处理延迟。

### %util

disk utilization，即磁盘带宽占用率。这个值最能够直观的体现出磁盘的压力，
如果发现util接近100%，那毫无疑问该机器遇到了io瓶颈。

## 如何分析

通常情况下，`%util`是我们首先要关注的，如果这个值很高，那么毫无疑问我
们遇到了io问题。

接下来，要根据`rkB/s`, `wkB/s`, `avgqu-sz`来判断io压力是
不是很大，分以下几种情况：

* 读或者写的量很大

没什么可说的，就是压力太大。。。

*  读写量都不大，但avgqu-sz很大

说明io压力不平均，可能某一小段时间爆发了大量的请求，导致请求队列中积累
了大量的待处理请求

* 读写量都不大，avgqu-sz也不大

首先要看看是不是读写混合型请求，如一个程序需要频繁的读写同一个文件，这
种情况下由于磁盘需要不断的寻道，吞吐会变得极低，可能只有几M/s。

其次，如果发现`rkB/s`和`wKB/s`都不大，但是`r/s`或`w/s`很大，这种情况下
`avgrq-sz`会比较小，说明程序在进行大量的小io操作，导致磁盘要进行大量的
寻道，极大的降低处理效率。

如果上面两种情况均不符合的话，就需要看一下`svctm`是不是正常，如果发现`svctm`异常的高，
那么很有可能是磁盘出现了硬件故障。

