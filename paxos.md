Paxos
=====

简介
--

Paxos是由Lamport在1989年提出的一种Consensus
Algorithm(字太多了，以下简称CA)，但是那篇paper极其晦涩难懂，所以下面所有的讨论都是依据其在2001年的Paxos Made
Simple，但这篇paper仍然比较难懂…...

The Problem
-----------

首先，我们要先了解CA所要解决的问题是什么？假设我们有若干个process(这里的process是一个抽象的概念，可能以任何形式存在)，其中每一个进程都可以propose一系列的值，如果我们想要这些进程能够选出同一个值，即让他们达到共识，就需要CA。

作为CA中的一种，Paxos的特点是能够在不可靠的分布式网络中，在一部分节点失效的情况下，仍然能够正常的运行。

为了保证安全性，任何一种CA都要满足以下三个要求：

-   只有被提出的值才有可能被选中

-   只有一个值能被选中

-   只有一个值真正被选中的时候，其他的进程才能得知这个值被选中了

CA中的参与者有三种角色，proposer,
acceptor和learner。在具体的实现中，一个进程可能同时扮演多种角色，由于这点与算法本身无关，我们在这里不做讨论。

我们假设参与者(agent)之间是通过发送消息来进行通信的。以下的整个讨论基于customary asynchronous, non-Byzantine
model(不用关心这是什么…….)，在这个模型中：

-   每一个agent的运行速度任意，并且可能会停止或重启。重启后的agent需要能够继续停止之前的状态，所以这就需要每个agent需要持久化其运行中的状态信息

-   消息专递所需要的时间可能为任意长，消息可能发生复制，丢失，但不会被损坏

Choosing a Value
----------------

最简单的方法是我们只用一个acceptor，然后proposer会将其提出的值发给acceptor，acceptor则会选择其收到的第一个值。显然，这个最简单的方法完全不靠谱，因为当这个唯一的acceptor挂掉时，整个系统也就死翘翘了。

那么我们来尝试一下另外的方法。既然一个acceptor不行，那么我们就使用多个acceptor。其中proposer会将其提议的值发给若干个acceptor。acceptor则可以选择接受其收到的某个值。当大部分的acceptor接受了同样的值时，我们就认为成功的选出了一个值。

下面我们根据CA的要求，来推导一下Paxos需要满足哪些属性。

首先，在没有出现节点失败或消息丢失的情况下，即使只有一个proposer提议了一个值，我们的算法也要能够选出一个值。通过满足下面的属性，我们可以做到这一点：

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
P1.一个acceptor必须接受(accept)他收到的第一个提议(proposal)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

不过仅仅满足这一属性的话会带来一个问题：若干个proposer可能会在同一时刻各自提一个不同的值，这样就会导致虽然每一个acceptor都接受了一个值，但是却没有一个值是被大部分acceptor共同接受的，这样就会导致算法失败。

P1和一个值只有在被大多数的acceptor接受时才会被选择这一要求，隐含了acceptor必须被允许接受多个proposal。我们这里定义每一个提议(proposal)都会有一个编号(proposal
number)和一个值(value)所组成。其中编号是全局唯一，且单调递增(具体怎么做是实现相关的)。当任何一个包含某个值的提议被大多数的acceptor接受时，我们就认为这个值被选中了。

简而言之，我们允许多个提议被选中，但是我们必须保证所有被选中的提议都包含同样的值。这就隐含着另外一个属性：

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
P2.如果一个值为v的proposal被选中，那么之后被选中的proposal的值均为v
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一个值要被选中，需要至少被一个acceptor接受。所以我们可以通过满足下面的属性来满足P2：

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
P2a.如果一个值为v的proposal被选中，那么之后被任何一个acceptor接受的proposal的值均为v
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

我们仍然需要通过满足P1来保证一定会有某个提议被选中。由于消息是异步传递的，所以可能会发生这么一种情况：虽然某个proposal被大多数的acceptor所接受，但是另外某个acceptor
c并没有收到任何的proposal。这个时候如果另外一个proposer提议了另一个不同的值，P1要求c必须接受这个proposal，这就违反了P2a。即并不是所有的acceptor接受的proposal都包含同样的值。这就需要我们将P2a加强为：

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
P2b.如果一个值为v的proposal被选中，那么之后任何一个proposer所提议的值均为v
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了满足P2b，我们需要维持下面一个不变量(invariant)：

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
P2c.对于任何v和n，如果出现了一个值为v编号的n的提议，那么一定存在一个由大部分的acceptor所组成的集合S，其中要么(a)S中的acceptor没有接受任何值，要么(b)S中acceptor接受的值为v。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

总之，上面说了这么多属性，最关键的地方就是P2c=\>P2b=\>P2a=\>P2这一推导关系，即我们只要想办法满足P2c即可。

所以为了满足P2c，如果一个proposer想要发起一个编号为n的proposal，他就首先需要获取之前编号小于n的proposal的信息，因为这些提议可能已经被或者将要被大部分的acceptor接受。获取已经被接受的proposal的信息非常简单，但想知道哪些可能将会被接受则非常困难。所以这里我们就要想办法绕过这个问题，使我们不必判断可能有哪些proposal“将”会被接受。换句话说，就是可以让proposer对acceptor发出请求，让他保证不会接受编号小于n的proposal，这样就产生了下面的算法：

1.  一个proposer选择一个新的编号n，然后向一部分的acceptor发出prepare请求，其响应包括下面两部分：

    a)  保证再也不会接受编号小于n的proposal

    b)  如果已经接受了某些proposal，则返回其中编号最大的proposal

2.  如果proposer收到了大部分的acceptor的响应，则他可以发出编号为n值为v的request请求了。这里的v要么是所有acceptor的响应中编号最大的proposal的值，要么是任意的值(如果所有的acceptor的响应中都没有包含proposal)。

以上就描述了proposer的算法，那么acceptor呢？acceptor可以接收两种请求：prepare和accept。一个acceptor可以忽略任意的请求而不影响整个算法的安全性，所以我们只需要考虑在哪些情况下，acceptor需要做出响应即可。acceptor可以响应任何的prepare请求。acceptor可以响应任何accept请求，只要他没保证不响应(好绕…….)。换句话说：

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
P1a.一个acceptor可以接受一个编号为n的accept请求，当且仅当他没有响应一个编号大于n的prepare请求
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

至此，我们就有了一个完整的算法，可以用来选择出某个值。整个算法应该比较清晰了，具体将proposer和acceptor的放在一起的部分我就不在这里重复，原文这部分写的也比较明白了。

Learning a Value
----------------

当一个值被选出来后，我们需要让learner都得知这一信息。最简单的办法是让acceptor在接受一个提议之后，通知所有的learner。这种情况下，产生的消息总量是acceptor的数量乘以learner的数量，比较庞大。

我们还可以选择让acceptor只通知某一个特别的learner(distinguished
learner)，然后让这个learner去通知其他的learner。这样做的好处是产生的消息数量会比较少，但是问题是如果这个learner挂掉，信息的传播就中断了。实际情况中，我们可以采用两者的折中方案，即acceptor将信息发送给一部分特别的learner(distinguished
learner)，然后由这些learner转发给其他learner……..

由于消息可能会丢失，所以可能出现某个值被选中了，但是learner却都没有发现。这种情况下，learner可以主动去问acceptor接受了哪些值，但是如果某些acceptor挂掉了，这就可能会导致learner没办法知道哪个值是被大多数的acceptor接受的。这种情况下，learner就只能等到有新的提议出现的时候才能知道选择的值。

Progress
--------

我们可以很容易的制造一种场景，两个proposer
p和q不断的交替发起一系列编号递增的proposal，比如p首先发起一个编号为n1的prepare请求，然后q发起编号为n2的prepare请求，其中n1\<n2，这时p的后续请求就会被拒绝，p重新发起编号为n3的prepare请求，其中n2\<n3，然后q的后续请求就会被拒绝，等等。这样的话，这个算法就不会终止。

为了保证这个算法能够正常的进行下去，我们需要选择某一个特别的proposer(distinguished
proposer)作为唯一一个可以发起proposal的proposer。如果这个proposer能够与大部分的acceptor进行通信，并且使用了一个目前为止最大的编号，那么他就一定可以成功的发起proposal。

The Implementation
------------------

在paxos的具体实现中，假设存在一堆的process，其中每一个process同时扮演proposer,acceptor和learner的角色。算法会使用外部机制选出一个leader，来扮演那个特别的proposer和learner(distinguished
proposer&learner)，负责发起proposal，并且在得知选出的值之后，将其告知其他的learner。持久化存储被用来维护acceptor的状态信息，一个acceptor在返回响应之前首先会将其意图写入持久化存储。

Implementing a State Machine
----------------------------

这部分是说如何利用paxos在若干个节点上维护若干份一致的log，在此之上实现一个Replicated State
Machine。这个解释起来略麻烦，等下一期再写…...




