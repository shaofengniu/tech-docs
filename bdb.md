# Berkeley DB调研文档

## 简介 (Overview)

Berkeley DB是一个开源的嵌入式数据库系统，支持多线程及多进程访问，并且
有着工业级别的事物支持，能够在某些系统或磁盘故障的情况下保证数据安全。

与Mysql等常见的数据库相比，BDB最大的特点是他是作为一个库，被直接链接进
应用程序中。BDB本身使用C编写，提供了C，C++，Perl，Tcl和Java可调用接口。

BDB的一大卖点是使用简单，但在实际使用中发现，想要发挥出BDB的全部能量，
并且进行异常的排查，并不是件很简单的事。另外，由于BDB现在已经成为
Oracle旗下的产品，虽号称开源软件，但是相关的社区基本为0，并且虽然号称
应用广泛，但在网络上基本查不到任何使用BDB的资料。再加上BDB的文档并不是
很完善，有些地方写的含糊不清，所以在具体使用或者问题追查的过程中，必然
要去深入他77万行的源码。

相比较于使用单独的DBMS，BDB可以由应用程序对其行为进行高度定制，比如可
以自定义BTree中的比较函数，或者Hash中的hash函数。

由于BDB并不是一个单独的Database Server，所以就需要我们对其进行封装，来
提供网络访问接口。

## 用例 (Use Case)

Oracle提的比较多，也是比较大的案例是Google的单点登陆系统
（Single-Sign-On），但是从公开的资料得不到这个系统的读写性能。并且这
个系统是由Google与Oracle深度合作的成果，所以对我们来说可参考性不高。


## 访问方式 (Access Method)

访问方式指的是数据是以何种方式在硬盘上存储的，不过的访问方式决定了数据
库能够支持何种操作和各种操纵的开销。例如大多数的数据库系统所支持的B+tree
访问方式，除了支持基于相等的查询，还支持范围查询。


BDB提供了四种访问方式：B+tree，Hash，Recno，Queue。在B+tree和Hash中，
每条记录的key可以是任意格式，而Recno和Queue则会为每一条记录分配一个逻
辑值，作为该条记录的key。在所有的访问方式中，value都可以具有任意格式，
BDB只是将其作为一个二进制安全的字符串来进行存取，对数据的任何解析都是
由应用程序来完成的。

### B+Tree

BDB中包含了一个标准的B+Tree的实现，即将key value对存在叶节点上，中间节
点只会存放key及子节点的指针。B+Tree中key存放的顺序是由一个比较函数来决
定，这个函数既可以使用BDB的默认实现，也可以由应用程序进行自定义。BDB中
的B+Tree提供了压缩功能，可以由应用程序提供压缩函数，来对插入B+Tree中的
数据进行压缩，这样可以在一定程度上减小数据库文件的大小，但是会对查询和
插入性能产生一定的影响。

其中Btree(B+Tree)在大多数情况下都是正确的选择，提供页级锁，读写性能均
令人满意。但是需要注意的一点是，BDB中的Btree是最原始的实现，并不像BDB
Java Edition中使用的是Log Structured Btree，这就导致往磁盘上写脏页的时
候，是一个准随机写入模式，对磁盘的压力会很大，进而影响到服务质量。

### Hash

Hash实现了标准的Extended Liner Hashing，可以随着记录数量的增长来自动
调整hash函数，来使得每个bucket的深度保持在可接受的程度。当数据集可以被
完全放入内存中时，Hash的查询和修改效率会更高一些。

### Recno & Queue

Recno和Queue均只支持int型的key，两者区别在于，Recno支持变长value，而
Queue只支持定长数据。Recno的实现是基于B+Tree，而Recno的实现则是将文件
当做一个简单的数组来使用。由于Queue可以直接由记录的逻辑编号算出该记录
在文件中的位置，所以其插入和修改的效率都非常高，比较适合计数类的应用。
此外，Queue支持记录粒度的锁，而Recno只支持页级别锁，所以Queue的并发性
能会好很多。


## Mpool

BDB中的所有Access Method都是构建在Mpool的抽象之上的，对底层文件的任何
读取修改都是经过Mpool来实施。

Mpool就是一个典型的cache，其提供了两个方法memp_trickle, 和 checkpoint
来定期将脏页刷到磁盘上，但BDB在这一点上的设计与实现存在如下问题：

首先，memp_trickle的初衷通过将一部分的脏页刷到磁盘上，来降低checkpoint
的工作量，进而降低checkpoint对整个服务的影响。但是由于BDB的Mpool并没有
实现LRU之类的页替换算法，trickle的具体实现中就是按照基本固定的规律对脏
页进行遍历，选出一定数量的脏页写到磁盘上，这就导致Mpool的数据存在热点
时，trickle方法可能会反复将热点数据写到磁盘上，而将老数据留在内存中，
这样不但没有减轻checkpoint的负担，反而因为频繁的磁盘写入加剧了io负担。

其次，checkpoint的实现也是最原始的fuzzy checkpoint，即每次checkpoint的
时候，都会将Mpool中的所有脏页全部写入硬盘，再加上我们之前说的，BDB的
Btree实现，会使得写模式近乎随机，这就导致在checkpoint的时候要进行大量
的随机写入，对整个服务器造成极大的影响。

那为什么同样使用Btree的InnoDB没有这样的问题？这是因为InnoDB的checkpoint
机制是一个fuzzy checkpoint的变种，每次只会写入10几个page，对服务器的性
能几乎不会产生影响，关于InnoDB中fuzzy checkpoint的机制在此不做赘述。


### Write-ahead logging

在一次Transaction中，应用程序可能会对数据库做出若干次的修改，其中每一
次的修改都会被记录在一条log中。BDB保证在将一个脏页写到磁盘之前，其所有
修改对应的log记录都已经被安全的写入磁盘。由于这些log里记录了数据库状态
发生的每一步变化，所以可以使用这些log来进行事物回滚或者数据库的恢复操
作。BDB在每次提交事物的时候，就会将对应的log写入磁盘，而内存中被修改的
数据，则会根据具体需求在之后的某个时间被写入磁盘。由于写log是顺序写，
而写脏页则是随机写，这样的做法就很大程度上提高了数据库的写入性能。


### Crashes and recovery

BDB会每隔一段时间进行一次checkpoint操作，将内存中的数据做一次快照保存
在磁盘上。而log中则记录了上一次的快照与当前数据库状态之间的变化。通过
数据库快照和log结合，可以将数据库恢复至最新的状态。为了最大限度的保证
数据的安全性，需要间隔性将数据库快照和log进行备份，并且为了性能考虑，
需要将快照和log放入不同的磁盘，以免checkpoint操作和读写log互相影响。

但是BDB有个问题，即使快照文件完好无损，但如果log文件发生了损坏或着丢失
的话，就没有法办正常运行。这时候唯一可以采取的方法就是通过BDB附带的工
具db\_dump和db\_load重做数据。

由于BDB在进行恢复操作的过程中，需要反复扫描从上次checkpoint开始的所有
log，这就使得recovery所需要的时间与checkpoint间隔成正比，但是又由于
checkpoint是一个开销很大的操作，所以又不适于频繁进行，这就比较尴尬。

### Transaction

虽然说Transaction是一个可选功能，但在实际使用中基本上是必选项，因为
Replication功能是基于Transaction Log来实现的，而我们在实际使用中又必然
会用到Replication。



### Replication

BDB的Replication基于Transaction Log实现，基本原理就是Master在处理请求
后，将该请求对应的Log发送至Slave，Slave就按照log对内存中的数据进行修改。

BDB的Replication提供了增量同步的功能，即在网络发生短暂抖动的情况下，可
以只同步缺失的部分，而不需要将整个数据集重新同步。但是在实际使用中发现
，其在同步的时候并不会对数据进行压缩，并且没有限速，这就导致在发生全量
同步的时候，网络短时占用率非常至高，可能会影响到其他服务的正常运行。

BDB的Replication提供了自动主从选举功能，可以在无需人工干预的情况下，完
成主从切换。但是需要注意的是，在一主一从，并且网络发生抖动的情况下，会
变成两个主库，如果在这段时间内，两个主库都接收到了写请求，那么在恢复通
信后，BDB会进行重新选举，由于BDB不会对写入到两台机器的数据进行merge，
写入到变成从机的那台机器的数据就会发生丢失。

